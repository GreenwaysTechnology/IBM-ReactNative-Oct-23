				 React fundamentals
.....................................................................................

What is React?

  React is javascript lib for building user interface 
  React is  java script lib like jquery,framework like angular.

What is User interface application?
 
  The user where he interacts , those applications are called user interface applications.

Eg:
  Desktop applications
     if you want to interact with os, shell is primary user interface
     shell in windows, command,powershell,explorer 

  Web Browser:
     It is one of the application software, acts as user interface for web applications
 
 Hand Held devices
  =>Mobile applications
  =>Watch
  =>Tabs
  =>TV
 etc..

.....................................................................................
				Types of web app
.....................................................................................

1.Static Web apps -  1989 to 1995
    built at server end,accessed by clients using browser
    HTML Pages are primary output.

2.Dynamic content web apps - 1996 to till date
    built at server end, access by clients using browser
eg:
  JEE(Servlets,jsp)
  Asp.net
  PHP
 etc.....

3.Web Services -1998 to till
    Data driven apps
     built at server end, accessed by clients  such  as mobiles, client side browser apps.
 SOAP - XML based web service
 RESTFull -  Different format based web service - JSON,XML,PDF....

....................................................................................
			  Client Side Web apps

1.SPA
Single Page Web Apps -  2007 to till date
   built at client side,accessed by clients browsers.
   built using javascript,html 5,css 3 

.....................................................................................
			 React and Web Stack
....................................................................................

React was created to build SPA Web apps by face book at 2013.
"React is modern SPA lib created by face book based on "Flux Design Pattern"
.....................................................................................

Architecture for libs and frameworks:

Plain JS
			 Application(dom) -plain js
			     |
			 Javascript Engine
			      |
			  Browser Engine




Framework/lib
			 Application(JQuery)
			     |
		       ---------------------------
			  JQuery Engine	------javascript programming		
                       -------------------------------
			      |
			 Javascript Engine -C/C++
			      |
			  Browser 

What is jquery engine?
  Jquery engine is also javascript program.


React


		       Application(React)
			     |
		       ---------------------------
	              React Engine :React fiber-->React 16 on wards		
                      ---------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine


React Engine itself is javascript

.....................................................................................
			  React Echo system
....................................................................................

Where is react used? What type of apps u can build using react.

React is every where from building browser based apps , mobile apps,server side web apps.
What ever type of app you build "React core" remains same.

React can be used to build application for 
........................................
1.browsers : Desktop -  Reactjs - SPA
2.Mobile Apps : React Native
3.Server side Apps: "Next.js"

face book is working on many futures projects related to react
4.React VR : Virtual Reality.
5.React Car : For car applications
6.React TV  : React for TV.
7.React IOT : any devices
...................................................................................
			   React core 
..................................................................................
React apps are written using a language called "JSX"

JSX language features are same but its "mark up" syntax would be different.

For Browser JSX markup would be "HTML"
For Mobile JSX markup would be "Mobile Elements"
.....................................................................................
React and Browser:
..................

Project setup:
..............
npx create-react-app my-app

Folder Structure

my-app
 |
 node_modules
 package.json
 package-lock.json
 public 
 src
 readme.md


node_modules
  It is folder contains all libs files and folders downloaded from internet.
  React lib has been downloaded and kept inside this folder only.

package.json
   Every javascript project(it can be any js project), has package.json file  
   This file contains information about the project

Basic information:
 ->Name of the application "name" :"myapp"
 ->version of the application "version": "1.0.0"
 ->dependencies
     libs  required for dev ,testing, production
    you can understand what version of lib is used in the current project
 ->scripts
     scripts contains information about how to start dev server,testing,production build.

public 
  index.html
  This is entry file in react application.
  without this file we cant start the application

src
 |
 index.js
  App.js
 This folder contains application code files.

readme.md
   this is documentation file
....................................................................................
	   		DOM programming 

What is DOM?
  Document Object model, which is spec to build and modify html pages on fly.

Object oriented HTML, HTML elements are represented as objects.

eg:
 H1 - Object
div - Object
 p  - Object


DOM helps to create objects on fly to attach on existing document
....................................................................................
				HTML works internally
.....................................................................................

HTML:

1.HTML IS PL? - YES
2.HTML Is compiled -YES
3.HTML is excuted-YES

java
 -source .java
 -compile -.class -assembly
 -excute -jvm--result


index.html -source code
  html code is organized as hierarchical model - hierarchical datastructure
  -tree

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
 |
 load the code into browser - loader
 |
 parsing - parser - Lexical Tree (string /text tree)

html
  |
 head
  | 
  head
   |
 title
    |
   test
    | 
  title
body
  |
  div
    |
     h1
      |  
      Welcome
     |
     h1
  div
   |
body
 |
html
  |
  compilation - compiler - converts code into assembly 

html - assembly instructions
  |
 head
  | 
  head
   |
 title
    |
   test
    | 
  title
body
  |
  div
    |
     h1
      |  
      Welcome
     |
     h1
  div
   |
body
 |
html
....................................................................................
Runtime:
  
  During Runtime, runtime allocates memory for each element.

 During runtime, browser creates node - Linked List - c language

html - Node
  | 
 head -Node
  | 
  head -Node
   |
 title
    |
   test
    | 
  title
body
  |
  div
    |
     h1
      |  
      Welcome
     |
     h1
  div
   |
body
 |
html

Finally all Linked List nodes forms the structure called "Tree Structure"

Once tree ready , Paint Engine/Layout Engine converts every node into "graphics/pixels"...


index.html---loader---parser--compiler--runtime--linkedlist---tree---graphics

.....................................................................................
				Dynamic HTML - Inside Web Browser
.....................................................................................

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?
  
One spec was published ,As per that spec
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be reprsented as Objects" : Object oriented Document Programming.

How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                 Every Html ELEMENT Inside Browser is "C Program"

	       Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.
******	

Who and when "H1" object is created?

if you want to create object?

 class/ function

function Employee(){}  let emp = new Employee()


<h1> => function HTMLHeadingElement(){} => let h =new HTMLHeadingElement() ?



if you want to create object?

 class/ function

function Employee(){}  let emp = new Employee()

<h1> => function HTMLHeadingElement(){} => let h =new HTMLHeadingElement() ?

Note: For html elements, we cant create object directly, rather than JS Engine will create objects , return references to the developer to access.

How via factory Objects: object helps to get other documents

Factory Object : HTML Document =>body

document.getElementById();
   |
Implicit object reference variable which points HTMLDocument OBject.


What is our objective here? DOM Programming?


Enter into DOM programming:

1.write dom programming using javascript language.

<body>
  |
HTMLDocument : body : factory Object


Document apis:

Finding HTML Elements:
......................

HTMLElement document.getElementById(id)	       Find an element by element id
HTMLElement Document document.getElementsByTagName(name)	Find elements by tag name
HTMLElement document.getElementsByClassName(name)	Find elements by class name
HTMLElement document.querySelectory(selector)        find element/elements by selector


Changing HTML Elements : update existing element
......................
element.innerHTML =  new html content	Change the inner HTML of an element
element.attribute = new value	Change the attribute value of an HTML element
element.style.property = new style	Change the style of an HTML element
Method	Description
element.setAttribute(attribute, value)	Change the attribute value of an HTML element

Adding and Deleting Elements:


document.createElement(element)	Create an HTML element
document.removeChild(element)	Remove an HTML element
document.appendChild(element)	Add an HTML element
document.replaceChild(new, old)	Replace an HTML element

.............................................................................................
				DOM Programming
.............................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.....
.....................................................................................
		How to create dom node , attach on existing tree
				using plain js

				
Note : 
 index.js

//How to create simple element using plain javascript

function createElement() {
    let Heading = document.createElement('h1')
    console.log(Heading)
    Heading.innerHTML = "Hello React!"
    let rootElement = document.getElementById('root')
    rootElement.appendChild(Heading)
}
createElement()
.....................................................................................
		How to create dom node , attach on existing tree
				using react.js

How to create dom node , attach on existing tree
				using react.js


import React from 'react';
import ReactDOM from 'react-dom/client';


//create react element
const Heading = <h1>Hello React!</h1>

//attach that react element with existing tree 
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(Heading)

The code above , we can see mixure of javascript and html.

How browser understands this code coimbination?

  The browser never understands this code directly.

What is this code is all about?
    
 Face book created a mini /small language for building react application - JSX language
.....................................................................................
				 Components
.....................................................................................

What is Component?
   Component  is nothing but "Object".

Component represents User Interface
Component is Object which represents User Interface.
User interface in browser is represented by HTML element or elements

Component can be represented some time , the object which helps to make up the Userinterface(invisible user interface).


element is <h1>Hello</h1>

elements are <div>
               <div>
                   <h1>Hello</h1>
               </div>
             </div>

Why We use Components model/Architecture?
  
=>Componets are independant objects.
=>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
 
Eg : 
 I am creating a component called "tax calculator".
 
lets say i want to use the tax calculator inside my hr application and inside my sale applcation , and purchase application.

How to create Components in react?

We have three patterns.

1.Variable Pattern
2.function pattern
3.ES 6 class Pattern

1.Variable pattern

import  ReactDOM  from "react-dom/client"

//component using variable pattern

const Heading = <h1>Hello React</h1>

const root =  ReactDOM.createRoot(document.getElementById('root'))
root.render(Heading)

2.function pattern
 import ReactDOM from "react-dom/client"


// function Heading() {
//     return <h1>Hello React!!</h1>
// }
// const Heading = () => {
//     return <h1>Hello React!!</h1>
// }
const Heading = () => <h1>Hello React!!</h1>

const root = ReactDOM.createRoot(document.getElementById('root'))
//imperative style
//root.render(Heading())
//declarative style
root.render(<Heading></Heading>)

3.class pattern:
 Modern react does not recommend to use this pattern.

import ReactDOM from "react-dom/client"
import React from "react"

class Heading extends React.Component {
    render() {
        return <h1>Hello!</h1>
    }
}

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<Heading></Heading>)
...................................................................................
			  JSX


JSX - Javascript and XML

What is JSX?
 JSX is dsl language to create user interfaces

What is relationship with XML?

 Inside JSX , we write javascript code and HTML code only not xml code.

Why the term XML is used?

 When we write JSX code, we need stable mark up standards.

You know very well HTML has weak parser  that means 
 <h1>hello
when run the code , the html parser does not stop rendering hello, it never throws any error.

in order to avoid instability code inside jsx during compilation, JSX team adopted XML Parser rules, since XML parser has strong parser

Basic XML  rules:

1.every opened element must be closed
  <h1>Hello</h1>
  <Welcome></Welcome>
 some elements may not have closing tag
  <img /> : image element has no child elements : self closing. 

2. In xml you must have one single root element.
  all elements must be organized under single root element.

 <h1>Welcome to React</h1>
 <p>Path finder</p>
 <h1>Welcome to React</h1>
 <p>Path finder</p>

In html what can be root element
 <div>,<span>,all html 5 layout elements header,footer,section,aside...

Note: some times i dont want root element, but how to avoid compiler errors
React uses a feature called "React fragements" using fragements you can avoid error..

React Fragement Syntax:

<React.Fragement><React.Fragement>
<Fragement></Fragement>
<></>
import ReactDOM from "react-dom/client"
import React, { Fragment } from "react"
// const Heading = () => <h1>IBM</h1>
//                 <p>This is react</p>


// const Heading = () => <div>
//      <h1>IBM</h1>
//     <p>This is react</p>
// </div>

//Using framgements
// const Heading = () => <React.Fragment>
//     <h1>IBM</h1>
//     <p>This is react</p>
// </React.Fragment>

// const Heading = () => <Fragment>
//     <h1>IBM</h1>
//     <p>This is react</p>
// </Fragment>
const Heading = () => <>
    <h1>IBM</h1>
    <p>This is react</p>
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<Heading></Heading>)


3.Component names should start with Uppercase,generally would be noun.

import ReactDOM from "react-dom/client"


// const heading = () => <>
//     <h1>IBM</h1>
//     <p>This is react</p>
// </>
const Heading = () => <>
    <h1>IBM</h1>
    <p>This is react</p>
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<Heading/>)
.....................................................................................
			How jsx code gets compiled?

How code gets compiled?

source code: jsx code

function Welcome() {
      return <h1>Welcome To React!</h1>;
}
|
babel.js - compiler 

compiled code

function Welcome() {
  return React.createElement(
    'h1',
    null,
    'Welcome To React!'
  );
}
|
runtime : react engine
function Welcome() {
  return React.createElement(
    'h1',
    null,
    'Welcome To React!'
  );
}
|
//React.createElement
function createElement(args){
   document.createElement(args); // low level api call
}
....................................................................................
			Component tree - Component Composition
...................................................................................

How to break large ui into smaller and smallar.

Why we need to create components?
 -Resuablity

DRY

How to create Component tree?

Lets look at the below markup and start thinking in the terms of components...

Blog

import ReactDOM from "react-dom/client"

//Blog Header:
const BlogHeader = () => <h1>My First Component</h1>

const BlogListItems = () => <>
    <li>Components are building blocks</li>
    <li>Components helps to reuse</li>
    <li>Components helps to scale ui</li>
</>

const BlogList = () => <ol>
    <BlogListItems />
</ol>

const Blog = () => {
    return <article>
        <BlogHeader />
        <BlogList />
    </article>
}

const App = () => <>
    <Blog />
    <Blog />
    <Blog />
    <Blog />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)

....................................................................................
			  Modularzation and Project layout
.....................................................................................

It means to spilt code,and to keep inside folders and files

Is there a recommended way to structure React projects?

React doesn’t have opinions on how you put files into folders. That said there are a few common approaches popular in the ecosystem you may want to consider.

1.Grouping by features or routes - This is recommended
2.Grouping by file types -  This is not recommended for large 
projects


common/
  Avatar.js
  Avatar.css
  APIUtils.js
  APIUtils.test.js
feed/
  index.js
  Feed.js
  Feed.css
  FeedStory.js
  FeedStory.test.js
  FeedAPI.js
profile/
  index.js
  Profile.js
  ProfileHeader.js
  ProfileHeader.css
  ProfileAPI.js


profile,feed,customers,products,payments which are "features"

Grouping by file type

api/
  APIUtils.js
  APIUtils.test.js
  ProfileAPI.js
  UserAPI.js
components/
  Avatar.js
  Avatar.css
  Feed.js
  Feed.css
  FeedStory.js
  FeedStory.test.js
  Profile.js
  ProfileHeader.js
  ProfileHeader.css

.....................................................................................

Eg:

src/index.js
import ReactDOM from "react-dom/client"
import { Blog } from "./blog/Blog"


const App = () => <>
    <Blog />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)

src/blog/Blog.jsx
import { BlogHeader } from "./BlogHeader"
import { BlogList } from "./BlogList"

export const Blog = () => {
    return <article>
        <BlogHeader />
        <BlogList/>
    </article>
}

src/blog/BlogHeader.jsx

export const BlogHeader = () => <h1>My First Component</h1>

src/blog/BlogList.jsx

import { BlogListItems } from "./BlogListItem"

export const BlogList = () => <ol>
    <BlogListItems />
</ol>

src/blog/BlogListItems.jsx

export const BlogListItems = () => <>
    <li>Components are building blocks</li>
    <li>Components helps to reuse</li>
    <li>Components helps to scale ui</li>
</>

In order to see the tree model, we can use react dev tool

https://react.dev/learn/react-developer-tools..


Assignment -1:

Build Layouts based on compoenent composition

 App
  |
 Page
   Header
     ->Logo
     ->SearchBar
   Body 
     ->Have three blogs
   Footer
     ->Copyright
.....................................................................................
			  Dynamic Page -  data binding
.....................................................................................
Types of app
1.static app
  only markup-html , hand coded.
2.dynamic app
   markup +data

How to add data in the component or How to bind data in the compoent?

Data can bet represented many ways

1.primitives - numbers,strings,booleans
2.objects - literals
3.collections - arrays 

let | const variableName ='value'

{variableName}-data binding

data binding can be 
{variable}
{expression} - {10*10} - {getValue()} {emp.id}

import ReactDOM from "react-dom/client"

//simple data binding 
const Greeter = () => {
    let message = 'Hello'
    return <h1>{message}</h1>
}


const App = () => <>
    <Greeter />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)

The above pattern is not recommended  to bind data.

Data can be bound to component in two ways

1.data is supplied from the outside the compoent
2.data is encapsulated with in the component



1.data is supplied from the outside the component
  When component receives data from  the outside, this pattern is called as "Property Pattern or Props Pattern".

Outside component means what? what is outside for the component?

You know very well, react creates components and assembles them in tree model, the one component is called parent compoent and other component is child component , some other compoents are called as sibilings.

outside means parent.

Data is supplied from the parent compoent to child component - props pattern

Imperative way of passing data to component.
import ReactDOM from "react-dom/client"

//child
const Greeter = (message) => {
    return <h1>{message}</h1>
}

//parent 
const App = () => <>
    {Greeter('Hello')}
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)

delcarative pattern:
import ReactDOM from "react-dom/client"

//child
const Greeter = props => {
    console.log(props)
    return <h1>{props.message} {props.name}</h1>
}

//parent 
const App = () => <>
    {/* {Greeter('Hello')} */}
    {/* data is encapsulated into object and passed */}
    <Greeter message="Hello"  name="Subramanian"/>
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)

Why props?

  Props helps components/widgets for configuration.


I am going to create Configurable Profile Component, so that i can supply different types of profile data.

import ReactDOM from "react-dom/client"

const Profile = props => {
    return <div>
        <h1>Id {props.id}</h1>
        <p>Name {props.name}</p>
        <p>Status {props.status ? "onLine" : "OffLine"}</p>
        <p>City {props.address.city}</p>
    </div>
}


//parent 
const App = () => <>
    <Profile id={1} name="Subramanian" status={true} address={{ city: 'Coimbatore' }} />
    <Profile id={2} name="Murugan" status={false} address={{ city: 'Chennai' }} />
    <Profile id={3} name="Ram" status={true} address={{ city: 'Banaglore' }} />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)

.....................................................................................
			Breaking component and passing data

import ReactDOM from "react-dom/client"

const Profile = props => <div>
    <h1>Id {props.id}</h1>
    <p>Name {props.name}</p>
    <Status status={props.status} />
    <Address address={props.address} />
</div>

const Status = props => <>
    <p>Status {props.status ? "onLine" : "OffLine"}</p>
</>
const Address = props => <>
    <p>City {props.address.city}</p>
</>


//parent 
const App = () => <>
    <Profile id={1} name="Subramanian" status={true} address={{ city: 'Coimbatore' }} />
    <Profile id={2} name="Murugan" status={false} address={{ city: 'Chennai' }} />
    <Profile id={3} name="Ram" status={true} address={{ city: 'Banaglore' }} />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
.....................................................................................
		  What if i dont supply props to compoents- default props
....................................................................................
import ReactDOM from "react-dom/client"

const Profile = props => <div>
    <h1>Id {props.id}</h1>
    <p>Name {props.name}</p>
    <Status status={props.status} />
    <Address address={props.address} />
</div>

const Status = props => <>
    <p>Status {props.status ? "onLine" : "OffLine"}</p>
</>
const Address = props => <>
    <p>City {props.address.city}</p>
</>

//default Props 
Profile.defaultProps = {
    id: 0,
    name: 'name',
    status: false,
    address: {
        city: 'city'
    }
}




//parent 
const App = () => <>
    <Profile />
    <Profile id={1} name="Subramanian" status={true} address={{ city: 'Coimbatore' }} />
    <Profile id={2} name="Murugan" address={{ city: 'Chennai' }} />

</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
.....................................................................................
			classes and props
.....................................................................................import React from "react"
import ReactDOM from "react-dom/client"

class Profile extends React.Component {
    render() {
        return <div>
            <h1>Id {this.props.id}</h1>
            <h1> Name {this.props.name}</h1>
            <Status status={this.props.status} />
            <Address address={this.props.address} />
        </div>
    }
}

const Status = props => <>
    <p>Status {props.status ? "onLine" : "OffLine"}</p>
</>
const Address = props => <>
    <p>City {props.address.city}</p>
</>

//default Props 
Profile.defaultProps = {
    id: 0,
    name: 'name',
    status: false,
    address: {
        city: 'city'
    }
}




//parent 
const App = () => <>
    <Profile />
    <Profile id={1} name="Subramanian" status={true} address={{ city: 'Coimbatore' }} />
    <Profile id={2} name="Murugan" address={{ city: 'Chennai' }} />

</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
....................................................................................
			 Object as prop...

import React from "react"
import ReactDOM from "react-dom/client"

const Profile = props => {
    return <div>
        <h1>Id {props.profile.id}</h1>
        <h1> Name {props.profile.name}</h1>
        <Status status={props.profile.status} />
        <Address address={props.profile.address} />
    </div>

}

const Status = props => <>
    <p>Status {props.status ? "onLine" : "OffLine"}</p>
</>
const Address = props => <>
    <p>City {props.address.city}</p>
</>

//default Props 
Profile.defaultProps = {
    profile: {
        id: 0,
        name: 'name',
        status: false,
        address: {
            city: 'city'
        }
    }
}
const profile = {
    id: 1,
    name: 'Subramanian',
    status: false,
    address: {
        city: 'Coimbatore'
    }
}
const App = () => <>
    <Profile profile={profile} />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
....................................................................................
			 Object destructuring and Props.

import React from "react"
import ReactDOM from "react-dom/client"

const Profile = props => {
    const { id, name, status, address } = props.profile
    return <div>
        <h1>Id {id}</h1>
        <h1> Name {name}</h1>
        <Status status={status} />
        <Address address={address} />
    </div>
}

const Status = ({ status }) => <>
    <p>Status {status ? "onLine" : "OffLine"}</p>
</>
const Address = ({ address: { city } }) => <>
    <p>City {city}</p>
</>

//default Props 
Profile.defaultProps = {
    profile: {
        id: 0,
        name: 'name',
        status: false,
        address: {
            city: 'city'
        }
    }
}
const profile = {
    id: 1,
    name: 'Subramanian',
    status: false,
    address: {
        city: 'Coimbatore'
    }
}
const App = () => <>
    <Profile profile={profile} />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
.....................................................................................
		 Property rethrow and Property Merging
.....................................................................................
import React from "react"
import ReactDOM from "react-dom/client"

const ProfileMaster = props => {
    // const { id, name, status, address } = props.profile
    return <div>
        {/* <ProfileDetails id={id} name={name} status={status} address={address} /> */}
        <ProfileDetails {...props.profile} />
    </div>
}

const ProfileDetails = ({ id, name, status, address: { city } }) => {
    return <>
        <h1>Id {id}</h1>
        <h4>Name {name}</h4>
        <h3>Status {status ? "Online" : "OffLine"}</h3>
        <h4>City {city}</h4>
    </>
}


const profile = {
    id: 1,
    name: 'Subramanian',
    status: false,
    address: {
        city: 'Coimbatore'
    }
}
const App = () => <>
    <ProfileMaster profile={profile} />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
.....................................................................................
			  List rendering
.....................................................................................
import React from "react"
import ReactDOM from "react-dom/client"

//simple list 
const NumberList = props => {
    return <div>
        <ul>
            {
                props.numbers.map(i => {
                    return <li key={i}>{i}</li>
                })
            }
        </ul>
    </div>
}


const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const App = () => <>
    <NumberList numbers={numbers} />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
............................

Complex Data:
import React from "react"
import ReactDOM from "react-dom/client"
import { TODOS } from './mock-data/todos'

const TodoList = ({ todos }) => {
    return <>
        {
            todos.map(todo => {
                return <div key={todo.id}>
                    <TodoDetails todo={todo} />
                </div>
            })
        }
    </>
}
const TodoDetails = ({ todo }) => <>
    <h4>{todo.id}</h4>
    <h3>{todo.title}</h3>
    <h3>{todo.completed ? "completed" : "not completed"}</h3>
</>

const App = () => <>
    <TodoList todos={TODOS} />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
....................................................................................
			 What can be a prop
....................................................................................

Prop can be 
1.data - numbers,strings,objects,arrays,boolean
2.function- function as prop
3.component/html elment can be prop

Component as Prop:

<Header/> -  This component no child
<Header> ? </Header> -This component has child..


import React from "react"
import ReactDOM from "react-dom/client"

const Header = props => {
    return <>
        <h1>{props.title}</h1>
        {props.children}
    </>
}

const MenuBar = props => {
    return <ul>
        {props.menus.map(menu => {
            return <li>{menu}</li>
        })}
    </ul>
}

const App = () => <>
    <Header title="IBM">
        {/* Passing menubar as prop */}
        <MenuBar menus={["Menu1", "Menu2", "Menu3", "Menu 4"]} />
    </Header>
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
.....................................................................................
			State Pattern
....................................................................................

What is state?
  Data is encapsulated inside compoent and we can change that data, when ever the data is changed, userinterface will re render....

How to declare state inside component?

=>inside class component - Until react 16...
=>Inside functions using Hooks - Recommended...

How to interact with UI ?
  Event Handling.

How to mutate(update) state?
  functional programming principls - pure functions and immutablity...


state declaration inside class compoent:
........................................

1.there is instance variable from React.Component base class called "state"
2.we need to declare that state variable inside our compoent class
3.state variable must hold always object
4.Object contains component data.

  state = {
        like: 0,
        dislike: 0
    }

The above one is inital state, which is intialized and displayed when ui is displayed first time.

import React from "react"
import ReactDOM from "react-dom/client"

class Review extends React.Component {

    //declare state 
    state = {
        like: 0,
        dislike: 0
    }

    render() {
        return <div>
            <h1>Review Application</h1>
            <h2>Like {this.state.like}</h2>
            <h2>Dislike {this.state.dislike}</h2>
        </div>
    }
}

const App = () => <>
    <Review />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)


How to change like and dislike variables?

Event Handling:

import React from "react"
import ReactDOM from "react-dom/client"

class Review extends React.Component {

    //declare state 
    state = {
        like: 0,
        dislike: 0
    }
    //Listener 
    onLike = () => {
        console.log('onLike is clicked')
    }
    onDislike = () => {
        console.log('onDislike is clicked')
    }

    render() {
        return <div>
            <h1>Review Application</h1>
            <h2>Like {this.state.like} Dislike {this.state.dislike}</h2>
            <button onClick={this.onLike}>Like</button>
            <button onClick={this.onDislike}>Dislike</button>
        </div>
    }
}

const App = () => <>
    <Review />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)

.....................................................................................
How React updates User interface?

via render method.

render:

=>render method is called by "react engine".

Can we call render method directly inside event listener...
Yes, but no impact on ui update...
   onLike = () => {
        this.state.like++
        console.log(this.state.like)
        this.render()
        console.log('onLike is clicked')
    }
Note: render should not called directly in order to update user interface..
....................................................................................
			functional programming principles and React
...................................................................................

Pure Functions:

Pure functions are defined by two rules..

Rule A:
  if function receives input, the function returns the input without any mutation...

Every component with respet to props, are pure functions..
import ReactDOM from "react-dom/client"
//Pure function Rule A:

function Profile(profile) {
    return profile
}

Profile({ id: 1, name: 'Subramaian' })


//child
const Greeter = props => {
    //cant change the prop :Props are read only 
   // props.message = 'Hai'
    console.log(props)
    return <h1>{props.message} {props.name}</h1>
}

//parent 
const App = () => <>
    {/* {Greeter('Hello')} */}
    {/* data is encapsulated into object and passed */}
    <Greeter message="Hello" name="Subramanian" />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)



Rule B:
.......
 if function receives input, what if i want to change(mutate),We can apply rule b.
 
if function receives input,and modify input , we should return new object every time, which is called immutablity. 

How to write immutable logic?

//Is it Pure..Impure function
// function updateProfile(profile, city) {
//     profile.city = city
//     return profile
// }
//ways to write immutablity : Pattern 1
// function updateProfile(profile, city) {
//     //new Profile Object
//     return {
//         id: profile.id,
//         name: profile.name,
//         city: city
//     }
// }
//Pattern 2
// function updateProfile(profile, city) {
//     //clone method
//     return Object.assign({}, profile, { city: city })
// }
//pattern 3:
function updateProfile(profile, city) {
    // Using spread notation
    return {
        ...profile,city:city
    }
}

const profile = {
    id: 1,
    name: 'Subramaian',
    city: 'New York'
}
console.log('Before update', profile)
const updatedProfile = updateProfile(profile, 'Coimbatore')
//check the profile
console.log(profile === updatedProfile ? "Same object" : "Different Object")
console.log('After update', updatedProfile)

List of Array immutable apis:
1.concat  - Adding new Item
2.map- iterate and transform update
3.filter,slice => delete
4.reverse,sort ->sorting and rever
..................................................................................
			Rule B :State mutations inside react
...................................................................................

call render?
render is call by react engine only.
how react engine will trigger render method?
 via react api "setState" ,forceUpdate

Syntax:
setState(updater,[callback])

updater:
 function having state mutation logic...

step:
 this.setState(function(state,props){

   return {}
 })

function(state,props){

 } - updater function

here state is just variable name you can have any name- Holds the value of state object which is called as "privous state or old state"

2.props is just variable holding current props variable- which is optional




import React from "react"
import ReactDOM from "react-dom/client"

class Review extends React.Component {

    //declare state 
    state = {
        like: 0,
        dislike: 0
    }
    //Listener 
    onLike = () => {
        this.setState((previousState, props) => {
            // return {
            //     like: previousState.like + 1,
            //     dislike: previousState.dislike
            // }
            // return Object.assign({}, previousState, { like: previousState.like + 1 })
            return { ...previousState, like: previousState.like + 1 }
        })
    }
    onDislike = () => {
        // this.setState((previousState, props) => {
        //     return { ...previousState, dislike: previousState.dislike + 1 }
        // })
        this.setState(previousState=> ({ ...previousState, dislike: previousState.dislike + 1 }))
    }

    render() {
        console.log('render is called')
        return <div>
            <h1>Review Application</h1>
            <h2>Like {this.state.like} Dislike {this.state.dislike}</h2>
            <button onClick={this.onLike}>Like</button>
            <button onClick={this.onDislike}>Dislike</button>
        </div>
    }
}

const App = () => <>
    <Review />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
............................................................

Inline listeners:

import React from "react"
import ReactDOM from "react-dom/client"

class Review extends React.Component {
    state = {
        like: 0,
        dislike: 0
    }
    render() {
        console.log('render is called')
        return <div>
            <h1>Review Application</h1>
            <h2>Like {this.state.like} Dislike {this.state.dislike}</h2>
            {/* inline listeners */}
            <button onClick={() => {
                this.setState(previousState => this.setState(previousState => ({ ...previousState, like: previousState.like + 1 })))
            }}>Like</button>
            <button onClick={() => {
                this.setState(previousState => ({ ...previousState, dislike: previousState.dislike + 1 }))
            }}>Dislike</button>
        </div>
    }
}

const App = () => <>
    <Review />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
....................................................................................
			Dynamic Props : state and function as prop.
//////////////////////////////////////////////////////////////////////////////////
import React from "react"
import ReactDOM from "react-dom/client"

class Review extends React.Component {
    state = {
        like: 0,
        dislike: 0
    }
    //biz 
    onLike = () => {
        this.setState(previousState => this.setState(previousState => ({ ...previousState, like: previousState.like + 1 })))
    }
    onDislike = () => {
        this.setState(previousState => this.setState(previousState => ({ ...previousState, dislike: previousState.dislike + 1 })))
    }
    render() {
        return <>
            {/* state as prop and function as prop: dynamic props */}
            <ReviewDisplay {...this.state} onLike={this.onLike} onDislike={this.onDislike} />
        </>
    }
}

const ReviewDisplay = props => {
    return <div>
        <h1>Review Application</h1>
        <h1>Like {props.like} Dislike {props.dislike}</h1>
        <button onClick={props.onLike}>Like</button>
        <button onClick={props.onDislike}>Dislike</button>

    </div>
}

const App = () => <>
    <Review />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
.................................................................................
			 Component Life Methods
................................................................................

can be classifie into 3 phases

1.mount
2.update
3.unmount

1.Mouting
 This is inital phase of an component.

The methods are called in order when an instance of a component is being created and inserted into the DOM.

render is called for preparing ui

componentDidMount is called after ui is ready, and all resource intensive tasks such as api calls,websocket calls ,timer code, all are written here.
...................................................................................
		 Web Service integration in Component Did Mount
.....................................................................................

How to integrate axax in react?
 React has no any api for talking to webservices
You can use any popular js ajax libs

1.fetch api
2.axios


fetch api:
.........
import React from "react"
import ReactDOM from "react-dom/client"

class Posts extends React.Component {

    state = {
        posts: []
    }

    async componentDidMount() {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        try {
            const posts = await (await fetch(url)).json()
            this.setState(previousState=>{
                return {...previousState,posts:previousState.posts.concat(posts)}
            })
        }
        catch (err) {
            console.log(err)
        }
    }
    render() {
        return <div>
            <h1>Posts Application</h1>
            <div>
                {
                    this.state.posts.map(post => {
                        return <div key={post.id}>
                            <h2>{post.id}</h2>
                            <h6>{post.title}</h6>
                            <p>{post.body}</p>
                        </div>
                    })
                }
            </div>
        </div>
    }
}


const App = () => <>
    <Posts />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
.....................................................................................
			 conditional rendering
.....................................................................................

There are three possibilites you have when you do ajax calls

1.you may have data on time
2.you may not have data on time- delay or slow calls
   we can show spinners
3.you may get error.
  server down,network failures, mal functions

you have to write code according to state of an api

1.success on time
2.success with spinner
3.error

how to write if...else conditions inside jsx?
 conditional rendering...


import React from "react"
import ReactDOM from "react-dom/client"


const Error = props => {
    return <>
        <h2>{props.error}</h2>
    </>
}
const Spinner = props => {
    return <>
        <h2>Loading....</h2>
    </>
}
const PostList = props => {
    return <div>
        {
            props.posts.map(post => {
                return <div key={post.id}>
                    <h2>{post.id}</h2>
                    <h6>{post.title}</h6>
                    <p>{post.body}</p>
                </div>
            })
        }
    </div>
}

class Posts extends React.Component {

    state = {
        isLoaded: false,//spinner status
        posts: [],
        error: null
    }

    async componentDidMount() {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        try {
            const posts = await (await fetch(url)).json()
            this.setState(previousState => {
                return { ...previousState, posts: previousState.posts.concat(posts), isLoaded: true }
            })
        }
        catch (err) {
            console.log(err)
            this.setState(previousState => {
                return {
                    ...previousState, isLoaded: true, error: err
                }
            })
        }
    }
    render() {
        //conditonal rendering 
        const { error, isLoaded, posts } = this.state
        if (error) {
            return <Error error={error} />
        } else if (!isLoaded) {
            return <Spinner />
        } else {
           return  <PostList posts={posts} />
        }
    }
}


const App = () => <>
    <Posts />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
.....................................................................................
			Hooks
....................................................................................

What is hook?
  It is a feature in react and react native to eleminate class components to make every thing functional components.

Why hooks?
 class components encasulate the biz logic which cant be reused across the application.

What is hook?
 hook is just javascript function, may take arg or may return value..

Convtionally every hook starts with "use" Notation

eg:
 useState
 useEffect
 useLayout
etc....

Hook types:
1.built in hooks provided by react
2.custom hooks, we can create our own hooks...
....................................................................................
			  useState - Hook
...................................................................................

import { useState } from "react"
import ReactDOM from "react-dom/client"

const Review = props => {

    const [like, setLike] = useState(0)
    const [dislike, setDisLike] = useState(0)

    //listener 
    const onLike = () => {
        // setLike(like => {
        //     return like + 1
        // })
        setLike(like + 1)
    }
    return <div>
        <h1>Review Application</h1>
        <h1>Like {like} Dislike {dislike}</h1>
        <button onClick={onLike}>Like</button>
        <button onClick={() => {
            setDisLike(dislike + 1)
        }}>Dislike</button>

    </div>
}

const App = () => <>
    <Review />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)

..................................................................................

Object inside hook:
...................
import { useState } from "react"
import ReactDOM from "react-dom/client"

const Review = props => {

    const [review, setReview] = useState({ like: 0, dislike: 0 })

    const onLike = () => {
        setReview(review => {
            //immutable object 
            return { ...review, like: review.like + 1 }
        })
    }

    return <div>
        <h1>Review Application</h1>
        <h1>Like {review.like} Dislike {review.dislike}</h1>
        <button onClick={onLike}>Like</button>
        <button onClick={() => {
            setReview(review => {
                //immutable object 
                return { ...review, dislike: review.dislike + 1 }
            })
        }}>Dislike</button>

    </div>
}

const App = () => <>
    <Review />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
....................................................................................
		 Component life cycles api and hooks
.................................................................................

Mount:
 componentDidMount 

Update
 componentDidUpdate

There is hook called "useEffect" for componentDidMount and componentDidUpdate

import { useEffect, useState } from "react"
import ReactDOM from "react-dom/client"


const Error = props => {
    return <>
        <h2>{props.error}</h2>
    </>
}
const Spinner = props => {
    return <>
        <h2>Loading....</h2>
    </>
}
const PostList = props => {
    console.log(props)
    return <div>
        {
            props.posts.map(post => {
                return <div key={post.id}>
                    <h2>{post.id}</h2>
                    <h6>{post.title}</h6>
                    <p>{post.body}</p>
                </div>
            })
        }
    </div>
}
const Posts = props => {
    let initalState = {
        isLoaded: false,
        items: [],
        error: null
    }
    const [posts, setPosts] = useState(initalState)

    async function fetchPosts() {
        try {
            const url = 'https://jsonplaceholder.typicode.com/posts'
            const values = await (await fetch(url)).json()
            setPosts({ ...posts, isLoaded: true, items: posts.items.concat(values) })
        }
        catch (err) {
            setPosts({ ...posts, isLoaded: true, error: err })

        }
    }

    //useEffect : ComponentDidMount 
    useEffect(() => {
        fetchPosts()
        console.log(posts)

    }, [])

    console.log(posts)
    const { error, isLoaded, items } = posts
    if (error) {
        return <Error error={error} />
    } else if (!isLoaded) {
        return <Spinner />
    } else {
        return <PostList posts={items} />
    }
}

const App = () => <>
    <Posts />
</>

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)



